/* This file has been automatically generated by RPC-Generator
   https://github.com/Crystal-Photonics/RPC-Generator
   You should not modify this file manually. */

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h> /* for size_t */

/* Return values used by some RPC functions */
typedef enum{
    RPC_SUCCESS,
    RPC_FAILURE,
    RPC_COMMAND_UNKNOWN,
    RPC_COMMAND_INCOMPLETE
} RPC_RESULT;

typedef struct {
	RPC_RESULT result;
	size_t size;
} RPC_SIZE_RESULT;

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   IMPORTANT: The following functions must be implemented by YOU.
   They are required for the RPC to work.
   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
   
void RPC_start_message(size_t size);
/*  This function is called when a new message starts. {size} is the number of
    bytes the message will require. In the implementation you can allocate  a
    buffers or write a preamble. The implementation can be empty if you do not
    need to do that. */

void RPC_push_byte(unsigned char byte);
/* Pushes a byte to be sent via network. You should put all the pushed bytes
   into a buffer and send the buffer when RPC_commit is called. If you run
   out of buffer you can send multiple partial messages as long as the other
   side puts them back together. */

RPC_RESULT RPC_commit(void);
/* This function is called when a complete message has been pushed using
   RPC_push_byte. Now is a good time to send the buffer over the network,
   even if the buffer is not full yet. You may also want to free the buffer that
   you may have allocated in the RPC_start_message function.
   RPC_commit should return RPC_SUCCESS if the buffer has been successfully
   sent and RPC_FAILURE otherwise. */

typedef enum {
    RPC_mutex_sender,
    RPC_mutex_expected,
    RPC_mutex_caller,
    RPC_mutex_caller_pause,
    RPC_mutex_parser_pause,
    RPC_mutex_count
} RPC_mutex_id;
#define RPC_number_of_mutex_ids 5
/* You need to define 5 mutexes to implement the RPC_mutex_* functions below.
   If the functions do not actually aquire and release mutexes with the described
   semantics the RPC code will not work. */

void RPC_mutex_lock(RPC_mutex_id mutex_id);
/* Locks the mutex and waits indefinitely */

char RPC_mutex_unlock(RPC_mutex_id mutex_id);
/* Unlocks the mutex. Returns 1 if the mutex was locked and 0 otherwise. */

char RPC_mutex_lock_timeout(RPC_mutex_id mutex_id);
/* Tries to lock a mutex. Returns 1 if the mutex was locked and 0 id a timeout
   occured. The timeout length should be the time you want to wait for an answer
   before giving up. If the time is infinite a lost answer will get the calling
   thread stuck indefinitely. */

void RPC_yield(void);
/* Gives control to another thread. Can be implemented by sleep(1ms). */

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   The following functions's implementations are automatically generated.
   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

void RPC_init(void);
/* Initializes various states required for the RPC. */

RPC_SIZE_RESULT RPC_get_answer_length(const void *buffer, size_t size);
/* Returns the (expected) length of the beginning of a (partial) message.
   If returnvalue.result equals RPC_SUCCESS then returnvalue.size equals the
   expected size in bytes.
   If returnvalue.result equals RPC_COMMAND_UNKNOWN then the buffer does not point
   to the beginning of a recognized message and returnvalue.size has no meaning.
   If returnvalue.result equals RPC_COMMAND_INCOMPLETE then returnvalue.size equals
   the minimum number of bytes required to figure out the length of the message. */

RPC_SIZE_RESULT RPC_parse_answer(const void *buffer, size_t size);
/* This function parses answer received from the network. {buffer} points to the
   buffer that contains the received data and {size} contains the number of bytes
   that have been received (NOT the size of the buffer!). This function will wake
   up RPC_*-functions below that are waiting for an answer.
   Returns RPC_SUCCESS on successful parse, RPC_COMMAND_INCOMPLETE when the message
   is incomplete and RPC_COMMAND_UNKNOWN if it is an unknown command. */

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   These are the payload functions made available by the RPC generator.
   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* //TODO: copy comments for documentation */
RPC_RESULT square(int32_t return_value_out[1], int32_t i);
RPC_RESULT test(int32_t return_value_out[1], uint16_t data_inout[42]);

#ifdef __cplusplus
}
#endif
